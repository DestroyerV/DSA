{
  "generatedAt": "2025-10-04T04:19:00.972Z",
  "files": [
    {
      "path": "arrays/containerWithMostWater.cpp",
      "name": "containerWithMostWater.cpp",
      "content": "// LC 11\n\n#include <iostream>\nusing namespace std;\n\nint bruteforce(int heights[], int n) // O(n^2)\n{\n    int maxArea = 0;\n    int width = 0;\n    int height = 0;\n    int area = 0;\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n            width = j - i;\n            height = min(heights[i], heights[j]);\n            area = width * height;\n            maxArea = max(area, maxArea);\n        }\n    }\n\n    return maxArea;\n}\n\nint optimal(int heights[], int n) // 2 Pointer Approach\n{\n    int maxWater = 0;\n    int lp = 0, rp = n - 1;\n\n    while (lp < rp)\n    {\n        int width = rp - lp;\n        int height = min(heights[lp], heights[rp]);\n        int area = width * height;\n        maxWater = max(area, maxWater);\n        heights[lp] < heights[rp] ? lp++ : rp--;\n    }\n\n    return maxWater;\n}\n\nint main()\n{\n    int heights[] = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    int n = sizeof(heights) / sizeof(heights[0]);\n\n    cout << \"Bruteforce: \" << bruteforce(heights, n) << endl;\n    cout << \"Optimal: \" << optimal(heights, n) << endl;\n}"
    },
    {
      "path": "arrays/largestSubarrayZeroSum.cpp",
      "name": "largestSubarrayZeroSum.cpp",
      "content": "#include <iostream>\n#include <unordered_map>\n\nusing namespace std;\n\nint main()\n{\n    int n = 8;\n    int nums[] = {15, -2, 2, -8, 1, 7, 10, 23};\n\n    // BruteForce\n    //  TC : O(N)\n    //  SC : O(1)\n\n    int maxLength = 0;\n\n    for (int i = 0; i < n; i++)\n    {\n        int sum = 0;\n\n        for (int j = i; j < n; j++)\n        {\n            sum += nums[j];\n\n            if (sum == 0)\n            {\n                maxLength = max(maxLength, j - i + 1);\n            }\n        }\n    }\n\n    cout << maxLength << endl;\n\n    // Optimal (Hashing)\n    // TC : O(N)\n    // SC : O(N)\n\n\n    \n\n    return 0;\n}"
    },
    {
      "path": "arrays/longestSubarray.cpp",
      "name": "longestSubarray.cpp",
      "content": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint getLongestSubarray(vector<int> &a, long long k)\n{\n    unordered_map<long long, int> preSumMap;\n    int n = a.size();\n    long long sum = 0;\n    int maxLen = 0;\n\n    for (int i = 0; i < n; i++)\n    {\n        sum += a[i];\n\n        if (sum == k)\n        {\n            maxLen = max(maxLen, i + 1);\n        }\n\n        long long rem = sum - k;\n\n        if (preSumMap.count(rem))\n        {\n            maxLen = max(maxLen, (i - preSumMap[rem]));\n        }\n\n        if (!preSumMap.count(sum))\n        {\n            preSumMap[sum] = i;\n        }\n    }\n    return maxLen;\n}\n\nint main()\n{\n    vector<int> a = {2, 3, 5, 1, 9};\n    long long k = 10;\n    int len = getLongestSubarray(a, k);\n    cout << \"The length of the longest subarray is: \" << len << endl;\n    return 0;\n}"
    },
    {
      "path": "arrays/majorityElement.cpp",
      "name": "majorityElement.cpp",
      "content": "// LC 169\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid bruteforce(vector<int> nums) // Big O(n^2)\n{\n    int n = nums.size();\n    for (int val : nums)\n    {\n        int freq = 0;\n        for (int el : nums)\n        {\n            if (el == val)\n            {\n                freq++;\n            }\n        }\n        if (freq > n / 2)\n        {\n            cout << val << endl;\n            break;\n        }\n    }\n}\n\nvoid optimal(vector<int> nums) // Big O(nlogn)\n{\n    int n = nums.size();\n\n    std::sort(nums.begin(), nums.end());\n\n    int freq = 1, ans = nums[0];\n\n    for (int i = 1; i < n; i++)\n    {\n        if (nums[i - 1] == nums[i])\n        {\n            freq++;\n        }\n        else\n        {\n            freq = 1;\n            ans = nums[i];\n        }\n\n        if (freq > n / 2)\n        {\n            cout << ans << endl;\n        }\n    }\n}\n\nvoid moorVotingAlgorithm(vector<int> nums) // Big O(n)\n{\n    int n = nums.size();\n    int freq = 0, ans = 0;\n\n    for (int i = 0; i < n; i++)\n    {\n        if (freq == 0)\n        {\n            ans = nums[i];\n        }\n\n        if (ans == nums[i])\n        {\n            freq++;\n        }\n        else\n        {\n            freq--;\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main()\n{\n    vector<int> nums{2, 2, 1, 1, 2};\n    moorVotingAlgorithm(nums);\n}"
    },
    {
      "path": "arrays/maxSubarray.cpp",
      "name": "maxSubarray.cpp",
      "content": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Maximum Subarray Sum - Kadane's Algorithm\nint maxSubArray(vector<int>& nums) {\n    int maxSum = nums[0];\n    int currentSum = nums[0];\n    \n    for (int i = 1; i < nums.size(); i++) {\n        currentSum = max(nums[i], currentSum + nums[i]);\n        maxSum = max(maxSum, currentSum);\n    }\n    \n    return maxSum;\n}\n\nint main() {\n    vector<int> nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    \n    int result = maxSubArray(nums);\n    cout << \"Maximum subarray sum: \" << result << endl;\n    \n    return 0;\n}\n"
    },
    {
      "path": "arrays/merge2SortedArray.cpp",
      "name": "merge2SortedArray.cpp",
      "content": "// LC 88\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Time O(m + n)\n// Space O(m + n) because of vector nums3 of size m + n\nvector<int> merge(vector<int> &nums1, vector<int> &nums2, int m, int n)\n{\n    int i = 0;\n    int j = 0;\n    vector<int> nums3;\n\n    while (i < m && j < n)\n    {\n        if (nums1[i] < nums2[j])\n        {\n            nums3.push_back(nums1[i]);\n            i++;\n        }\n        else\n        {\n            nums3.push_back(nums2[j]);\n            j++;\n        }\n    }\n\n    while (i < m)\n    {\n        nums3.push_back(nums1[i]);\n        i++;\n    }\n\n    while (j < n)\n    {\n        nums3.push_back(nums2[j]);\n        j++;\n    }\n\n    return nums3;\n}\n\n// O(1) SC\nvoid optimizeSpace(vector<int> &nums1, vector<int> &nums2, int m, int n)\n{\n    nums1.resize(m + n);\n    int idx = m + n - 1, i = m - 1, j = n - 1;\n\n    while (i >= 0 && j >= 0)\n    {\n        if (nums1[i] >= nums2[j])\n        {\n            nums1[idx--] = nums1[i--];\n        }\n        else\n        {\n            nums1[idx--] = nums2[j--];\n        }\n    }\n\n    while (j >= 0)\n    {\n        nums1[idx--] = nums2[j--];\n    }\n}\nint main()\n{\n    vector<int> nums1 = {1, 2, 3};\n    vector<int> nums2 = {2, 5, 6};\n    int m = nums1.size();\n    int n = nums2.size();\n    // vector<int> nums3 = merge(nums1, nums2, m, n);\n    optimizeSpace(nums1, nums2, m, n);\n\n    for (int i = 0; i < nums1.size(); i++)\n    {\n        cout << nums1[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"
    },
    {
      "path": "arrays/nextPermution.cpp",
      "name": "nextPermution.cpp",
      "content": "// LC 31\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid nextPermutation(vector<int> &arr, int n) // TC: O(n) & SC: O(1)\n{\n    // Find the pivot\n\n    int pivot = -1;\n\n    for (int i = n - 2; i >= 0; i--)\n    {\n        if (arr[i] < arr[i + 1])\n        {\n            pivot = i;\n            break;\n        }\n    }\n\n    if (pivot == -1)\n    {\n        reverse(arr.begin(), arr.end());\n        return;\n    }\n\n    // Next larger element\n\n    for (int i = n - 1; i >= pivot; i--)\n    {\n        if (arr[i] > arr[pivot])\n        {\n            swap(arr[i], arr[pivot]);\n            break;\n        }\n    }\n\n    // Reverse (pivot + 1 to n-1)\n\n    int i = pivot + 1, j = n - 1;\n\n    while (i <= j)\n    {\n        swap(arr[i], arr[j]);\n        i++;\n        j--;\n    }\n}\n\nint main()\n{\n    vector<int> arr = {1, 2, 3, 5, 4};\n    int n = arr.size();\n    nextPermutation(arr, n);\n\n    for (int i = 0; i < n; i++)\n    {\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"
    },
    {
      "path": "arrays/pairSum.cpp",
      "name": "pairSum.cpp",
      "content": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> bruteForce(vector<int> nums, int target)\n{\n    vector<int> ans;\n    int n = nums.size();\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = i + 1; j < n; j++)\n        {\n            if (nums[i] + nums[j] == target)\n            {\n                ans.push_back(i);\n                ans.push_back(j);\n                return ans;\n            }\n        }\n    }\n\n    return ans;\n}\n\nvector<int> optimal(vector<int> nums, int target)\n{\n    vector<int> ans;\n    int n = nums.size();\n\n    int i = 0, j = n - 1;\n\n    while (i < j)\n    {\n        int pairSum = nums[i] + nums[j];\n\n        if (pairSum < target)\n        {\n            i++;\n        }\n        else if (pairSum > target)\n        {\n            j--;\n        }\n        else\n        {\n            ans.push_back(i);\n            ans.push_back(j);\n            return ans;\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    vector<int> nums{2, 7, 11, 15};\n    int target = 9;\n\n    vector<int> ans = optimal(nums, target);\n\n    std::cout << ans[0] << \", \" << ans[1] << endl;\n\n    return 0;\n}"
    },
    {
      "path": "arrays/productOfArray.cpp",
      "name": "productOfArray.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\n// LC 238\n\nint *bruteforce(int nums[], int n)\n{\n    int *ans = new int[n];\n\n    for (int i = 0; i < n; i++)\n    {\n        int product = 1;\n        for (int j = 0; j < n; j++)\n        {\n            if (i != j)\n            {\n                product *= nums[j];\n            }\n        }\n        ans[i] = product;\n    }\n    return ans;\n}\n\nint *optimal(int nums[], int n)\n{\n    int *ans = new int[n];\n    for (int i = 0; i < n; i++)\n    {\n        ans[i] = 1;\n    }\n\n    for (int i = 1; i < n; i++)\n    {\n        ans[i] = ans[i - 1] * nums[i - 1];\n    }\n\n    int suffix = 1;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        ans[i] *= suffix;\n        suffix *= nums[i];\n    }\n\n    return ans;\n}\n\nint main()\n{\n    int nums[] = {1, 2, 3, 4};\n    int n = sizeof(nums) / sizeof(nums[0]);\n    int *result = optimal(nums, n);\n    for (int i = 0; i < n; i++)\n    {\n        cout << result[i] << \" \";\n    }\n    delete[] result;\n    return 0;\n}\n"
    },
    {
      "path": "arrays/rotateMatrix.cpp",
      "name": "rotateMatrix.cpp",
      "content": "// LC 48\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> bruteForce(vector<vector<int>> &matrix, int m, int n)\n{\n    vector<vector<int>> ans(m, vector<int>(n, 0));\n\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            int temp = matrix[i][j];\n            ans[j][n - 1 - i] = temp;\n        }\n    }\n    return ans;\n}\n\nvoid optimal(vector<vector<int>> &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = i; j < n; j++)\n        {\n\n            swap(matrix[i][j], matrix[j][i]);\n        }\n    }\n\n    for (int i = 0; i < m; i++)\n    {\n        reverse(matrix[i].begin(), matrix[i].end());\n    }\n}\n\nint main()\n{\n    vector<vector<int>> matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int m = matrix.size();\n    int n = matrix[0].size();\n\n    // Before\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cout << matrix[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n\n    // vector<vector<int>> ans = bruteForce(matrix, m, n);\n\n    optimal(matrix, m, n);\n\n    // After\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cout << matrix[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}"
    },
    {
      "path": "arrays/second.cpp",
      "name": "second.cpp",
      "content": "#include <iostream>\n#include <limits.h> // Required for INT_MIN and INT_MAX\n\nusing namespace std;\n\nint secondLargestFn(int arr[], int n)\n{\n    // Handle arrays with less than 2 elements\n    if (n < 2)\n    {\n        return -1; // Or handle as an error\n    }\n    int largest = INT_MIN;\n    int secondLargest = INT_MIN;\n    for (int i = 0; i < n; i++)\n    {\n        if (arr[i] > largest)\n        {\n            secondLargest = largest;\n            largest = arr[i];\n        }\n        // Check if current element is between largest and secondLargest\n        else if (arr[i] > secondLargest && arr[i] != largest)\n        {\n            secondLargest = arr[i];\n        }\n    }\n    return secondLargest;\n}\n\nint secondSmallestFn(int arr[], int n)\n{\n    // Handle arrays with less than 2 elements\n    if (n < 2)\n    {\n        return -1; // Or handle as an error\n    }\n    int smallest = INT_MAX;\n    int secondSmallest = INT_MAX;\n    for (int i = 0; i < n; i++)\n    {\n        if (arr[i] < smallest)\n        {\n            secondSmallest = smallest;\n            smallest = arr[i];\n        }\n        // Check if current element is between smallest and secondSmallest\n        else if (arr[i] < secondSmallest && arr[i] != smallest)\n        {\n            secondSmallest = arr[i];\n        }\n    }\n    return secondSmallest;\n}\n\nint main()\n{\n    int arr[] = {10, 5, 8, 20, 12};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int secondLargest = secondLargestFn(arr, n);   // Should be 12\n    int secondSmallest = secondSmallestFn(arr, n); // Should be 8\n    cout << \"Second Largest: \" << secondLargest << endl;\n    cout << \"Second Smallest: \" << secondSmallest << endl;\n    return 0;\n}"
    },
    {
      "path": "arrays/spiralMatrix.cpp",
      "name": "spiralMatrix.cpp",
      "content": "// LC 54\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> spiral(vector<vector<int>> &matrix, int m, int n)\n{\n    vector<int> ans;\n    int top = 0, right = n - 1, bottom = m - 1, left = 0;\n\n    while (top <= bottom && left <= right)\n    {\n        // top: left -> right\n        for (int i = left; i <= right; i++)\n        {\n            ans.push_back(matrix[top][i]);\n        }\n        top++;\n\n        // right: top -> bottom\n        for (int i = top; i <= bottom; i++)\n        {\n            ans.push_back(matrix[i][right]);\n        }\n        right--;\n\n        // bottom: right -> left\n        if (top <= bottom)\n        {\n\n            for (int i = right; i >= left; i--)\n            {\n                ans.push_back(matrix[bottom][i]);\n            }\n            bottom--;\n        }\n\n        // left: bottom -> top\n        if (left <= right)\n        {\n\n            for (int i = bottom; i >= top; i--)\n            {\n                ans.push_back(matrix[i][left]);\n            }\n            left++;\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    vector<vector<int>> matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int m = matrix.size();\n    int n = matrix[0].size();\n\n    // Before\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cout << matrix[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n\n    vector<int> ans = spiral(matrix, m, n);\n\n    // After\n    for (int i = 0; i < ans.size(); i++)\n    {\n        cout << ans[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
    },
    {
      "path": "arrays/subArray.cpp",
      "name": "subArray.cpp",
      "content": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nvector<int> vec{3, 5, 1, 4, 2};\nint n = vec.size();\n\nvoid printSubArray()\n{\n    for (int st = 0; st < n; st++)\n    {\n        for (int end = st; end < n; end++)\n        {\n            for (int i = st; i <= end; i++)\n            {\n                cout << vec[i];\n            }\n            cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid bruteForceMaxSum()\n{\n\n    int maxSum = INT_MIN;\n\n    for (int st = 0; st < n; st++)\n    {\n        int currSum = 0;\n        for (int end = st; end < n; end++)\n        {\n            currSum += vec[end];\n            maxSum = max(currSum, maxSum);\n        }\n    }\n\n    cout << maxSum << endl;\n}\n\nvoid kadanAlgo()\n{\n    int maxSum = INT_MIN;\n    int currSum = 0;\n\n    for (int i = 0; i < n; i++)\n    {\n        currSum += vec[i];\n        maxSum = max(currSum, maxSum);\n\n        if (currSum < 0)\n        {\n            currSum = 0;\n        }\n    }\n    cout << maxSum;\n}\n\nint main()\n{\n    // cout << \"All Sub Arrays: \" << endl;\n    // printSubArray();\n\n    // cout << \"Max sum of sub arrays: \";\n    // bruteForceMaxSum();\n\n    std::cout << \"Optimized: \";\n    kadanAlgo();\n}\n"
    },
    {
      "path": "arrays/tempCodeRunnerFile.cpp",
      "name": "tempCodeRunnerFile.cpp",
      "content": " = 0; i <"
    },
    {
      "path": "arrays/twoSum.cpp",
      "name": "twoSum.cpp",
      "content": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Two Sum Problem - Find pair with given sum\nvector<int> twoSum(vector<int>& nums, int target) {\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            if (nums[i] + nums[j] == target) {\n                return {i, j};\n            }\n        }\n    }\n    return {};\n}\n\nint main() {\n    vector<int> nums = {2, 7, 11, 15};\n    int target = 9;\n    \n    vector<int> result = twoSum(nums, target);\n    \n    if (!result.empty()) {\n        cout << \"Indices: \" << result[0] << \", \" << result[1] << endl;\n    } else {\n        cout << \"No solution found\" << endl;\n    }\n    \n    return 0;\n}\n"
    },
    {
      "path": "arrays/union.cpp",
      "name": "union.cpp",
      "content": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> unionFn(int arr1[], int arr2[], int n, int m)\n{\n    vector<int> unionArr;\n    int i = 0, j = 0;\n\n    while (i < n && j < m)\n    {\n        if (arr1[i] <= arr2[j])\n        {\n            if (unionArr.size() == 0 || unionArr.back() != arr1[i])\n            {\n                unionArr.push_back(arr1[i]);\n            }\n            i++;\n        }\n        else\n        {\n            if (unionArr.size() == 0 || unionArr.back() != arr2[j])\n            {\n                unionArr.push_back(arr2[j]);\n            }\n            j++;\n        }\n    }\n\n    while (i < n)\n    {\n        if (unionArr.back() != arr1[i])\n        {\n            unionArr.push_back(arr1[i]);\n        }\n        i++;\n    }\n\n    while (j < m)\n    {\n        if (unionArr.back() != arr2[j])\n        {\n            unionArr.push_back(arr2[j]);\n        }\n        j++;\n    }\n\n    return unionArr;\n}\n\nint main()\n{\n    int n = 10, m = 7;\n    int arr1[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int arr2[] = {2, 3, 4, 4, 5, 11, 12};\n    vector<int> unionArr = unionFn(arr1, arr2, n, m);\n\n    for (auto &val : unionArr)\n    {\n        cout << val << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
    },
    {
      "path": "binarySearch/SearchInRotatedArray.cpp",
      "name": "SearchInRotatedArray.cpp",
      "content": "// LC 33\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    vector<int> nums = {3, 4, 5, 6, 7, 0, 1, 2};\n    int target = 0;\n    int start = 0;\n    int end = nums.size() - 1;\n\n    while (start <= end)\n    {\n        int mid = start + (end - start) / 2;\n\n        if (nums[mid == target])\n            cout << mid << endl;\n\n        if (nums[start] <= nums[mid]) // Left side sorted\n        {\n            if (nums[start] <= target && target <= nums[mid])\n            {\n                end = mid - 1;\n            }\n            else\n            {\n                start = mid + 1;\n            }\n        }\n        else // Right sorted\n        {\n            if (nums[mid] <= target && target <= nums[end])\n            {\n                start = mid + 1;\n            }\n            else\n            {\n                end = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}"
    },
    {
      "path": "binarySearch/aggresiveCow.cpp",
      "name": "aggresiveCow.cpp",
      "content": "/*\nAssign C cows to N stalls such that min distance between them is largest possible.\nReturn largest minimum distance.\n\nExample\n\nInput\nC = 3\nN = 5\narr = [1, 2, 3, 8, 9]\n\nOutput: 3\n\nExplanation:\nOne optimal placement is [1, 3, 6]\nMinimum distance between cows is 3\n\n*/\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool isPossible(vector<int> &arr, int N, int C, int minAllowed)\n{\n    int cows = 1;\n    int lastStall = arr[0];\n\n    for (int i = 0; i < N; i++)\n    {\n        if (arr[i] - lastStall >= minAllowed)\n        {\n            cows++;\n            lastStall = arr[i];\n        }\n\n        if (cows == C)\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint getDistance(vector<int> &arr, int N, int C)\n{\n    sort(arr.begin(), arr.end());\n\n    if (C > N)\n        return -1;\n\n    int start = 1;\n    int end = arr[N - 1] - arr[0];\n    int ans = -1;\n\n    while (start <= end)\n    {\n        int mid = start + (end - start) / 2;\n\n        if (isPossible(arr, N, C, mid))\n        {\n            ans = mid;\n            start = mid + 1;\n        }\n        else\n        {\n            end = mid - 1;\n        }\n    }\n\n    return ans;\n}\n\nint main()\n{\n    int N = 5, C = 3;\n    vector<int> arr = {1, 2, 3, 8, 4, 9};\n\n    cout << getDistance(arr, N, C) << endl;\n    return 0;\n}"
    },
    {
      "path": "binarySearch/binarySearch.cpp",
      "name": "binarySearch.cpp",
      "content": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint binarySearch(vector<int> arr, int target) // TC: O(log n), SC O(1)\n{\n    int start = 0, end = arr.size() - 1;\n\n    while (start <= end)\n    {\n        int mid = start + (end - start) / 2; // Prevent int overflow\n\n        if (target < arr[mid])\n        {\n            end = mid - 1;\n        }\n        else if (target > arr[mid])\n        {\n            start = mid + 1;\n        }\n        else\n        {\n            return mid;\n        }\n    }\n    return -1;\n}\n\nint recursiveBinarySearch(vector<int> arr, int target, int start, int end) // TC: O(log n), SC O(log n)\n{\n    int mid = start + (end - start) / 2;\n\n    if (target > arr[mid])\n    {\n        return recursiveBinarySearch(arr, target, mid + 1, end);\n    }\n    else if (target < arr[mid])\n    {\n        return recursiveBinarySearch(arr, target, start, mid - 1);\n    }\n    else\n    {\n        return mid;\n    }\n    return -1;\n}\n\nint main()\n{\n    vector<int> arr = {-1, 0, 3, 4, 5, 9, 12};\n    int target = 12;\n    int start = 0, end = arr.size() - 1;\n    cout << recursiveBinarySearch(arr, target, start, end) << endl;\n    return 0;\n}"
    },
    {
      "path": "binarySearch/book.cpp",
      "name": "book.cpp",
      "content": "// Google Asked question\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isValid(vector<int> &arr, int n, int m, int maxAllowedPages) // O(n)\n{\n    int student = 1, pages = 0;\n\n    for (int i = 0; i < n; i++)\n    {\n        if (arr[i] > maxAllowedPages)\n        {\n            return false;\n        }\n\n        if (pages + arr[i] <= maxAllowedPages)\n        {\n            pages += arr[i];\n        }\n        else\n        {\n            student++;\n            pages = arr[i];\n        }\n    }\n\n    return student > m ? false : true;\n}\n\nint allocateBook(vector<int> &arr, int n, int m) // O(log N * n)\n{\n    if (m > n)\n    {\n        return -1;\n    }\n    int sum = 0;\n    for (int i = 0; i < n; i++) // O(n)\n    {\n        sum += arr[i];\n    }\n\n    int ans = -1;\n    int start = 0, end = sum; // range of possible answers\n\n    while (start <= end) // O(log N * n)\n    {\n        int mid = start + (end - start) / 2;\n\n        if (isValid(arr, n, m, mid))\n        {\n            ans = mid;\n            end = mid - 1;\n        }\n        else\n        {\n            start = mid + 1;\n        }\n    }\n\n    return ans;\n}\n\nint main()\n{\n    vector<int> arr = {2, 1, 3, 4};\n    int n = 4, m = 2;\n\n    cout << allocateBook(arr, n, m) << endl;\n    return 0;\n}"
    },
    {
      "path": "binarySearch/floorCeil.cpp",
      "name": "floorCeil.cpp",
      "content": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int arr[] = {3, 4, 4, 7, 8, 10};\n    int n = 6;\n    int x = 8;\n\n    int floor = -1, ceil = -1;\n\n    int start = 0, end = n - 1;\n\n    while (start <= end)\n    {\n        int mid = start + (end - start) / 2;\n\n        if (arr[mid] <= x)\n        {\n            floor = arr[mid];\n            start = mid + 1;\n        }\n        else\n        {\n            end = mid - 1;\n        }\n    }\n\n    start = 0, end = n - 1;\n\n    while (start <= end)\n    {\n        int mid = start + (end - start) / 2;\n\n        if (arr[mid] >= x)\n        {\n            ceil = arr[mid];\n            end = mid - 1;\n        }\n        else\n        {\n            start = mid + 1;\n        }\n    }\n\n    cout << floor << \" \" << ceil << endl;\n}"
    },
    {
      "path": "binarySearch/nRoot.cpp",
      "name": "nRoot.cpp",
      "content": "#include <iostream>\nusing namespace std;\nstruct HashTable{\n    vector<int> table;\n    int m;\n    HashTable(int size): m(size){\n        table.assign(m,-1);\n    }\n    void insert(int key){\n        int idx = key % m;\n        int start = idx;\n        while(table[idx]!=-1){\n            idx = (idx + 1) % m;\n            if(idx==start){ cout<<\"Table full\\n\"; return; }\n        }\n        table[idx] = key;\n    }\n    bool search(int key){\n        int idx = key % m;\n        int start = idx;\n        while(table[idx]!=-1){\n            if(table[idx]==key) return true;\n            idx = (idx + 1) % m;\n            if(idx==start) break;\n        }\n        return false;\n    }\n    void display(){\n        for(int i=0;i<m;i++) cout<<i<<\":\"<<table[i]<<\" \";\n        cout<<\"\\n\";\n    }\n};\nint main(){\n    HashTable h(7);\n    h.insert(10);\n    h.insert(20);\n    h.insert(5);\n    h.insert(15);\n    cout<<\"Hash table:\\n\";\n    h.display();\n    cout<<\"Search 20: \"<<(h.search(20)?\"Found\":\"Not Found\")<<\"\\n\";\n    return 0;\n}\n"
    },
    {
      "path": "binarySearch/occurance.cpp",
      "name": "occurance.cpp",
      "content": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int nums[] = {2, 2, 3, 3, 3, 3, 4};\n    int n = 7;\n    int x = 3;\n\n    int freq = -1;\n\n    int start = 0, end = n - 1;\n    while (start <= end)\n    {\n        int mid = start + (end - start);\n\n        if (nums[mid] == x)\n        {\n            freq++;\n            end = mid - 1;\n        }\n        else if (nums[mid] < x)\n        {\n            start = mid + 1;\n        }\n        else\n        {\n            end = mid - 1;\n        }\n    }\n\n    start = 0, end = n - 1;\n    while (start <= end)\n    {\n        int mid = start + (end - start);\n\n        if (nums[mid] == x)\n        {\n            freq++;\n            start = mid + 1;\n        }\n        else if (nums[mid] < x)\n        {\n            start = mid + 1;\n        }\n        else\n        {\n            end = mid - 1;\n        }\n    }\n    cout << freq << endl;\n    return 0;\n}"
    },
    {
      "path": "binarySearch/paintersPartition.cpp",
      "name": "paintersPartition.cpp",
      "content": "// Same Approach of Book Allocation Problem\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool isValid(vector<int> &arr, int n, int m, int maxAllowed)\n{\n    int painter = 1;\n    int length = 0;\n\n    for (int i = 0; i < n; i++)\n    {\n        if (arr[i] > maxAllowed)\n        {\n            return false;\n        }\n\n        if (length + arr[i] <= maxAllowed)\n        {\n            length += arr[i];\n        }\n        else\n        {\n            painter++;\n            length = arr[i];\n        }\n    }\n\n    return painter > m ? false : true;\n}\n\nint painterPartition(vector<int> &arr, int n, int m)\n{\n    if (m > n)\n        return -1;\n\n    // All possible solution\n    int sum = 0;\n    for (int i = 0; i < n; i++)\n    {\n        sum += arr[i];\n    }\n\n    int ans = -1;\n    int start = 0;\n    int end = sum;\n\n    while (start <= end)\n    {\n        int mid = start + (end - start) / 2;\n\n        if (isValid(arr, n, m, mid))\n        {\n            ans = mid;\n            end = mid - 1;\n        }\n        else\n        {\n            start = mid + 1;\n        }\n    }\n\n    return ans;\n}\n\nint main()\n{\n    vector<int> arr = {40, 30, 10, 20};\n    int n = 4;\n    int m = 2;\n\n    cout << painterPartition(arr, n, m) << endl;\n    return 0;\n}"
    },
    {
      "path": "binarySearch/peakMountain.cpp",
      "name": "peakMountain.cpp",
      "content": "// LC 852\n\n// 1. Linear search O(n)\n// 2. Binary Search O(logn)\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    vector<int> arr = {0, 3, 8, 9, 5};\n    // Peak element is never at 0th and last index because it is given in question that it is a mountain array and mountain array is always increasing and then decreasing so peak element is always present in the middle of the array and minimum length of array is 3.\n    int start = 1;\n    int end = arr.size() - 2;\n\n    while (start <= end)\n    {\n        int mid = start + (end - start) / 2;\n        if (arr[mid] > arr[mid - 1] && arr[mid] > arr[mid + 1])\n        {\n            cout << arr[mid] << endl;\n            break;\n        }\n        else if (arr[mid] < arr[mid + 1])\n        {\n            start = mid + 1;\n        }\n        else\n        {\n            end = mid - 1;\n        }\n    }\n    return -1;\n}"
    },
    {
      "path": "binarySearch/singleElement.cpp",
      "name": "singleElement.cpp",
      "content": "// LC 540\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint singleNonDuplicate(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n == 1)\n    {\n        return nums[0];\n    }\n    int start = 0;\n    int end = n - 1;\n\n    while (start <= end)\n    {\n        int mid = start + (end - start) / 2;\n\n        if (mid == 0 && nums[0] != nums[1])\n        {\n            return nums[mid];\n        }\n\n        if (mid == n - 1 && nums[n - 1] != nums[n - 2])\n        {\n            return nums[mid];\n        }\n\n        if (nums[mid] != nums[mid - 1] && nums[mid] != nums[mid + 1])\n        {\n            return nums[mid];\n        }\n\n        if (mid % 2 == 0)\n        {\n            if (nums[mid] == nums[mid - 1])\n            {\n                end = mid - 1;\n            }\n            else\n            {\n                start = mid + 1;\n            }\n        }\n        else\n        {\n            if (nums[mid] == nums[mid - 1])\n            {\n                start = mid + 1;\n            }\n            else\n            {\n                end = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    vector<int> nums = {1, 1, 2, 3, 3, 4, 4, 8, 8};\n    cout << singleNonDuplicate(nums) << endl;\n}"
    },
    {
      "path": "binarySearch/sqrt.cpp",
      "name": "sqrt.cpp",
      "content": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n = 36;\n\n    int ans = 0;\n\n    //Brute Force\n\n    // for (int i = 0; i <= n; i++)\n    // {\n    //     if ((i * i) <= n)\n    //     {\n    //         ans = i;\n    //     }\n    // }\n\n    // Optimal\n\n    int start = 0, end = n;\n\n    while (start <= end){\n        int mid = start + (end - start) / 2;\n\n        if((mid * mid) <= n){\n            start = mid + 1;\n            ans = mid;\n        }else{\n            end = mid - 1;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
    },
    {
      "path": "binarySearch/upperBound.cpp",
      "name": "upperBound.cpp",
      "content": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int arr[] = {1, 2, 2, 3};\n    int n = 4;\n    int x = 2;\n    int ans = -1;\n\n    int start = 0, end = n - 1;\n\n    while (start <= end)\n    {\n        int mid = start + (end - start) / 2;\n\n        if (arr[mid] > x)\n        {\n            ans = mid;\n            end = mid - 1;\n        }\n        else\n        {\n            start = mid + 1;\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
    },
    {
      "path": "bitwise/binaryToDecimal.cpp",
      "name": "binaryToDecimal.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nint binaryToDecimalFn(int n)\n{\n    int ans = 0;\n    int power = 1;\n\n    while (n > 0)\n    {\n        int rem = n % 10;\n        n /= 10;\n        ans += rem * power;\n        power *= 2;\n    }\n\n    return ans;\n}\n\nint main()\n{\n    cout << \"Enter a binary: \";\n    int n = 01101;\n    // cin >> n;\n    cout << binaryToDecimalFn(n) << endl;\n}"
    },
    {
      "path": "bitwise/bitManuplation.cpp",
      "name": "bitManuplation.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nunsigned int reverseBits(unsigned int n)\n{\n    unsigned int rev = 0;\n    int bitCount = sizeof(n) * 8; // Number of bits in an unsigned int\n\n    for (int i = 0; i < bitCount; i++)\n    {\n        // Extract the last bit of n\n        int lastBit = n & 1;\n\n        // Shift rev to the left to make space for the new bit\n        rev <<= 1;\n\n        // Set the last bit of rev to the extracted bit\n        rev |= lastBit;\n\n        // Shift n to the right to process the next bit\n        n >>= 1;\n    }\n\n    return rev;\n}\n\nint main()\n{\n    unsigned int n;\n    cout << \"Enter a number: \";\n    cin >> n;\n\n    unsigned int reversedBits = reverseBits(n);\n    cout << \"Reversed bits: \" << reversedBits << endl;\n\n    return 0;\n}\n"
    },
    {
      "path": "bitwise/decimalToBinary.cpp",
      "name": "decimalToBinary.cpp",
      "content": "// To convert any decimal number into binary number divide the decimal number by 2 because the binary is the base 2 number and the decimal is base 10 number so, divide the decimal number by 2 until you don't get the 0 in quotient after that arrange the reminder of each division in reverse order and that's the binary number.\n\n// eg. 6\n// 6/2 --> Q = 3, rem = 0\n// 3/2 --> Q = 1, rem = 1\n// Binary is 10\n\n#include <iostream>\nusing namespace std;\n\nint decimalToBinaryFn(int n)\n{\n    int ans = 0;\n    int power = 1; // places like unit, tens\n\n    while (n > 0)\n    {\n        int rem = n % 2;\n        n /= 2;\n        ans += rem * power; // arrange reminder in reverse order\n        power *= 10;\n    }\n\n    return ans;\n}\n\nint main()\n{\n    cout << \"Enter a number: \";\n    int n;\n    cin >> n;\n    cout << decimalToBinaryFn(n) << endl;\n}"
    },
    {
      "path": "hashing/mapHashing.cpp",
      "name": "mapHashing.cpp",
      "content": "#include <iostream>\n#include <unordered_map>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n    int arr[n];\n\n    for (int i = 0; i < n; i++)\n    {\n        cin >> arr[i];\n    }\n\n    unordered_map<int, int> mp;\n    for (int i = 0; i < n; i++)\n    {\n        mp[arr[i]]++;\n    }\n\n    for (auto it : mp)\n    {\n        cout << it.first << \" --> \" << it.second << endl;\n    }\n\n    return 0;\n}"
    },
    {
      "path": "maths/buyAndSell.cpp",
      "name": "buyAndSell.cpp",
      "content": "// LC 121\n\n#include <iostream>\nusing namespace std;\n\nint maxProfit(int stocks[6])\n{\n    int maxProfit = 0;\n    int bestBuy = stocks[0];\n\n    for (int i = 1; i < 6; i++)\n    {\n        if (stocks[i] > bestBuy)\n        {\n            maxProfit = max(maxProfit, stocks[i] - bestBuy);\n        }\n        bestBuy = min(bestBuy, stocks[i]);\n    }\n\n    return maxProfit;\n}\n\nint main()\n{\n    int stocks[6] = {7, 1, 5, 3, 6, 4};\n\n    cout << maxProfit(stocks) << endl;\n\n    return 0;\n}"
    },
    {
      "path": "maths/gcd.cpp",
      "name": "gcd.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\n// Euclid's Algorithm\nint gcd(int a, int b)\n{\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint main()\n{\n    int a, b;\n    cin >> a >> b;\n\n    cout << gcd(a, b) << endl;\n\n    return 0;\n}"
    },
    {
      "path": "maths/lcm.cpp",
      "name": "lcm.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\n// Function to calculate GCD of two numbers\nint gcd(int a, int b)\n{\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\n// Function to calculate LCM of two numbers\nint lcm(int a, int b)\n{\n    return (a * b) / gcd(a, b);\n}\n\nint main()\n{\n    int num1, num2;\n    cout << \"Enter two numbers: \";\n    cin >> num1 >> num2;\n\n    cout << \"LCM of \" << num1 << \" and \" << num2 << \" is \" << lcm(num1, num2) << endl;\n\n    return 0;\n}"
    },
    {
      "path": "maths/plandromeNumber.cpp",
      "name": "plandromeNumber.cpp",
      "content": "//LC 9\n\n#include <iostream>\nusing namespace std;\n\nbool isPalindrome(int num)\n{\n    int originalNum = num;\n    int reversedNum = 0;\n\n    while (num > 0)\n    {\n        int digit = num % 10;\n        reversedNum = reversedNum * 10 + digit;\n        num /= 10;\n    }\n\n    return originalNum == reversedNum;\n}\n\nint main()\n{\n    int number;\n    cout << \"Enter a number: \";\n    cin >> number;\n\n    if (isPalindrome(number))\n    {\n        cout << number << \" is a palindrome.\" << endl;\n    }\n    else\n    {\n        cout << number << \" is not a palindrome.\" << endl;\n    }\n\n    return 0;\n}"
    },
    {
      "path": "maths/power.cpp",
      "name": "power.cpp",
      "content": "// LC 50\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    double x = 3; // Base\n    int n = 5;    // Exponent\n\n    long binform = n;\n    double ans = 1;\n\n    if (n == 0)\n        return 1.0;\n\n    if (x == 0)\n        return 0.0;\n\n    if (x == 1)\n        return 1.0;\n\n    if (x == -1 && n % 2 == 0)\n        return 1.0;\n\n    if (x == -1 && n % 2 != 0)\n        return -1;\n\n    if (n < 0)\n    {\n        x = 1 / x;\n        binform = -binform;\n    }\n\n    while (binform > 0)\n    {\n        if (binform % 2 == 1)\n        {\n            ans *= x; // Multiply by current x if the current bit of binform is 1\n        }\n        x *= x;       // Square x\n        binform /= 2; // Shift binform to the right\n    }\n\n    cout << binform << ans << endl; // Output: 243 (which is 3^5)\n\n    return 0;\n}\n"
    },
    {
      "path": "maths/primeNumber.cpp",
      "name": "primeNumber.cpp",
      "content": "// LC 204\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid sieveOfEratosthenes(int n)\n{\n    vector<bool> prime(n + 1, true);\n    prime[0] = prime[1] = false;\n\n    for (int p = 2; p * p <= n; ++p)\n    {\n        if (prime[p])\n        {\n            for (int i = p * p; i <= n; i += p)\n            {\n                prime[i] = false;\n            }\n        }\n    }\n\n    for (int p = 2; p <= n; ++p)\n    {\n        if (prime[p])\n        {\n            cout << p << \" \";\n        }\n    }\n    cout << endl;\n}\n\nint main()\n{\n    int n;\n    cout << \"Enter the limit: \";\n    cin >> n;\n    sieveOfEratosthenes(n);\n    return 0;\n}"
    },
    {
      "path": "maths/reverseNumber.cpp",
      "name": "reverseNumber.cpp",
      "content": "#include <iostream>\n#include <limits.h>\nusing namespace std;\n\nint reverseNumber(int num)\n{\n    int reversed = 0;\n    while (num != 0)\n    {\n        int digit = num % 10;\n        if (reversed > INT_MAX / 10 || reversed < INT_MIN / 10)\n        {\n            return 0;\n        }\n        reversed = reversed * 10 + digit;\n        num /= 10;\n    }\n    return reversed;\n}\n\nint main()\n{\n    int number;\n    cout << \"Enter a number: \";\n    cin >> number;\n    int reversedNumber = reverseNumber(number);\n    cout << \"Reversed Number: \" << reversedNumber << endl;\n    return 0;\n}"
    },
    {
      "path": "matrices/diagonalSum.cpp",
      "name": "diagonalSum.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nint diagonalSum(int matrix[4][4], int n)\n{\n    int sum = 0;\n\n    for (int i = 0; i < n; i++)\n    {\n        sum += matrix[i][i];\n        if (i != n - i - 1)\n        {\n            sum += matrix[i][n - i - 1];\n        }\n    }\n    return sum;\n}\n\nint main()\n{\n    int matrix[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int n = 4;\n    cout << diagonalSum(matrix, n) << endl;\n}"
    },
    {
      "path": "matrices/matrix.cpp",
      "name": "matrix.cpp",
      "content": "#include <iostream>\n#include <utility>\nusing namespace std;\n\n// return row and column number of the linear search index using pair ctl\n//  maximum row sum\n//  maximum column sum\n\nint maxRowSum(int matrix[2][2], int row, int column)\n{\n    int maxSum = INT_MIN;\n    for (int i = 0; i < row; i++)\n    {\n        int currentSum = 0;\n        for (int j = 0; j < column; j++)\n        {\n            currentSum += matrix[i][j];\n        }\n        maxSum = max(maxSum, currentSum);\n    }\n    return maxSum;\n}\n\npair<int, int> linearSearch(int matrix[2][2], int key, int row, int column)\n{\n    for (int i = 0; i < row; i++)\n    {\n        for (int j = 0; j < column; j++)\n        {\n            if (matrix[i][j] == key)\n            {\n                return pair<int, int>(i, j);\n            }\n        }\n    }\n    return pair<int, int>(-1, -1);\n}\n\nint main()\n{\n    int matrix[2][2] = {{1, 2}, {3, 4}};\n    int row = 2;\n    int column = 2;\n    int key = 3;\n    // pair<int, int> p1 = linearSearch(matrix, key, row, column);\n    // cout << p1.first << \" \" << p1.second << endl;\n    cout << maxRowSum(matrix, row, column) << endl;\n    return 0;\n}"
    },
    {
      "path": "oops/containerClass.cpp",
      "name": "containerClass.cpp",
      "content": "#include <iostream>\n\nusing namespace std;\n\nclass Stack\n{\nprivate:\n    int *items;\n    int capacity;\n    int top;\n\npublic:\n    Stack(int size)\n    {\n        items = new int[size];\n        capacity = size;\n        top = -1;\n    }\n\n    ~Stack(){\n        delete[] items;\n    }\n\n    void push(int x)\n    {\n        if (top >= capacity - 1)\n        {\n            cout << \"Stack Overflow\" << endl;\n            return;\n        }\n        items[++top] = x;\n    }\n\n    int pop()\n    {\n        if (top < 0)\n        {\n            cout << \"Stack Underflow\" << endl;\n            return -1;\n        }\n        return items[top--];\n    }\n};\n\nint main()\n{\n    Stack s(5);\n\n    s.push(1);\n    s.push(2);\n    s.push(3);\n    s.push(4);\n    s.push(5);\n\n    cout << s.pop() << endl;\n\n    return 0;\n}"
    },
    {
      "path": "oops/copyConstructor.cpp",
      "name": "copyConstructor.cpp",
      "content": "#include <iostream>\n\nusing namespace std;\n\nclass Vector\n{\nprivate:\n    int *data;\n    int size;\n\npublic:\n    // Constructor\n    Vector(int s)\n    {\n        size = s;\n        data = new int[size];\n        for (int i = 0; i < size; i++)\n        {\n            data[i] = 0;\n        }\n    }\n\n    // Copy constructor\n    Vector(const Vector &source)\n    {\n        size = source.size;\n        data = new int[size];\n        for (int i = 0; i < size; i++)\n        {\n            data[i] = source.data[i];\n        }\n        cout << \"Copy constructor called\" << endl;\n    }\n\n    // Destructor\n    ~Vector()\n    {\n        delete[] data;\n    }\n\n    void setValue(int index, int value)\n    {\n        if (index >= 0 && index < size)\n        {\n            data[index] = value;\n        }\n    }\n\n    void display()\n    {\n        for (int i = 0; i < size; i++)\n        {\n            cout << data[i] << \" \";\n        }\n        cout << endl;\n    }\n};\n\nint main()\n{\n    Vector v1(3);\n    v1.setValue(0, 10);\n    v1.setValue(1, 20);\n    v1.setValue(2, 30);\n\n    Vector v2 = v1; // Copy constructor called\n\n    v1.display(); // Output: 10 20 30\n    v2.display(); // Output: 10 20 30\n\n    return 0;\n}"
    },
    {
      "path": "oops/friendClass.cpp",
      "name": "friendClass.cpp",
      "content": "#include <iostream>\n\nusing namespace std;\n\nclass A\n{\nprivate:\n    int privateData;\n\npublic:\n    A()\n    {\n        privateData = 10;\n    }\n\n    friend class B;\n};\n\nclass B\n{\npublic:\n    void getInto(A a)\n    {\n        cout << a.privateData << endl;\n    }\n};\n\nint main()\n{\n    A a;\n    B b;\n    b.getInto(a);\n    return 0;\n}"
    },
    {
      "path": "oops/friendFunction.cpp",
      "name": "friendFunction.cpp",
      "content": "#include <iostream>\n\nusing namespace std;\n\nclass Box\n{\nprivate:\n    double height, width;\n\npublic:\n    Box(double h, double w)\n    {\n        height = h;\n        width = w;\n    }\n\n    friend double area(Box b);\n};\n\ndouble area(Box b)\n{\n    return b.height * b.width;\n}\n\nint main()\n{\n    Box b(2, 5);\n\n    cout << \"Area: \" << area(b) << endl;\n    return 0;\n}"
    },
    {
      "path": "oops/inheriantance.cpp",
      "name": "inheriantance.cpp",
      "content": "#include <iostream>\n\nusing namespace std;\n\nclass Animal\n{\npublic:\n    void eat()\n    {\n        cout << \"Eating...\" << endl;\n    }\n};\n\n// Single Inheritance\nclass Dog : public Animal\n{\npublic:\n    void bark()\n    {\n        cout << \"Barking\" << endl;\n    }\n};\n\n// Multilevel Inheritance\nclass Bird : public Dog\n{\npublic:\n    void fly()\n    {\n        cout << \"Flying\" << endl;\n    }\n};\n\nint main()\n{\n    Bird tom;\n    return 0;\n}"
    },
    {
      "path": "oops/operatorOverloading.cpp",
      "name": "operatorOverloading.cpp",
      "content": "#include <iostream>\n\nusing namespace std;\n\nclass Complex\n{\nprivate:\n    double real, imag;\n\npublic:\n    Complex(double r = 0, double i = 0)\n    {\n        real = r;\n        imag = i;\n    }\n\n    // Overloading the + operator\n    Complex operator+(const Complex &obj)\n    {\n        Complex result;\n        result.real = real + obj.real;\n        result.imag = imag + obj.imag;\n        return result;\n    }\n\n    void display()\n    {\n        cout << real << \" + \" << imag << \"i\" << endl;\n    }\n};\n\nint main()\n{\n    Complex c1(3, 4), c2(5, 6), c3;\n    c3 = c1 + c2; // c1.operator+(c2)\n    c3.display(); // Output: 8 + 10i\n    return 0;\n}\n"
    },
    {
      "path": "oops/poly.cpp",
      "name": "poly.cpp",
      "content": "#include <iostream>\n\nusing namespace std;\n\nclass Animal\n{\npublic:\n    virtual void makeSound()\n    {\n        cout << \"Animal makes a sound\" << endl;\n    }\n};\n\nclass Dog : public Animal\n{\npublic:\n    void makeSound() override\n    {\n        cout << \"Barking\" << endl;\n    }\n};\n\nclass Cat : public Animal\n{\npublic:\n    void makeSound() override\n    {\n        cout << \"Meow\" << endl;\n    }\n};\n\nint main()\n{\n    Animal *animals[3];\n    animals[0] = new Animal();\n    animals[1] = new Dog();\n    animals[2] = new Cat();\n\n    for (int i = 0; i < 3; i++)\n    {\n        animals[i]->makeSound();\n    }\n    return 0;\n}"
    },
    {
      "path": "patterns/diamondPattern.cpp",
      "name": "diamondPattern.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nint n = 4;\n\nint main()\n{\n\n    // upper part\n    for (int i = 0; i < n; i++)\n    {\n\n        // spaces\n        for (int j = i; j < n - 1; j++)\n        {\n            cout << \" \";\n        }\n\n        // satrs\n        for (int j = 0; j <= i; j++)\n        {\n            cout << \" *\";\n        }\n        cout << endl;\n    }\n\n    // lower part\n    for (int i = n; i > 0; i--)\n    {\n        // spaces\n        for (int j = i; j < n; j++)\n        {\n            cout << \" \";\n        }\n\n        // satrs\n        for (int j = 0; j < i; j++)\n        {\n            cout << \" *\";\n        }\n        cout << endl;\n    }\n}"
    },
    {
      "path": "patterns/invertedPyramid.cpp",
      "name": "invertedPyramid.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n    // main loop\n    int n = 5;\n    for (int i = n; i > 0; i--)\n    {\n        // space\n        for (int j = i; j < n; j++)\n        {\n            cout << \" \";\n        }\n\n        // print\n        for (int j = 0; j < i; j++)\n        {\n            cout << \" *\";\n        }\n        cout << endl;\n    }\n}"
    },
    {
      "path": "patterns/patter13.cpp",
      "name": "patter13.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patternPrint(int n)\n{\n    int count = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n            count++;\n            cout << count;\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patternPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern1.cpp",
      "name": "pattern1.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patterPrint(int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patterPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern10.cpp",
      "name": "pattern10.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patterPrint(int n)\n{\n    // upper-half\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n\n    // lower-half\n    for (int i = n - 1; i >= 1; i--)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patterPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern11.cpp",
      "name": "pattern11.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patternPrint(int n)\n{\n    int count = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n            count++;\n            if ((count % 2) == 0)\n            {\n                cout << 0;\n            }\n            else\n            {\n                cout << 1;\n            }\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patternPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern12.cpp",
      "name": "pattern12.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patternPrint(int n){\n    for(int i = 1; i <= n; i++){\n        //number\n        for(int j = 1; j<= i; j++){\n            cout << j;\n        }\n        //spaces\n        for(int j = i; j < n; j++){\n            cout << \" \";\n        }\n        //second spaces\n        for(int j = i; j < n; j++){\n            cout << \" \";\n        }\n        // number\n        for(int j = i; j >= 1; j--){\n            cout << j;\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    patternPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern14.cpp",
      "name": "pattern14.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patternPrint(int n)\n{\n    for (int i = 1; i <= n; i++)\n    {\n        char c = 'A';\n        for (int j = 1; j <= i; j++)\n        {\n            cout << c;\n            c++;\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patternPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern15.cpp",
      "name": "pattern15.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patternPrint(int n)\n{\n    for (int i = n; i >= 1; i--)\n    {\n        char c = 'A';\n        for (int j = 1; j <= i; j++)\n        {\n            cout << c;\n            c++;\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patternPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern16.cpp",
      "name": "pattern16.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patternPrint(int n)\n{\n    char c = 'A';\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n            cout << c;\n        }\n        cout << endl;\n        c++;\n    }\n}\n\nint main()\n{\n    patternPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern17.cpp",
      "name": "pattern17.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patternPrint(int n)\n{\n    for (int i = 1; i <= n; i++)\n    {\n        // spaces\n        for (int j = n; j > i; j--)\n        {\n            cout << \" \";\n        }\n\n        // letter\n        char c1 = 'A';\n        for (int j = 1; j <= i; j++)\n        {\n            cout << c1;\n            c1++;\n        }\n        // second letter\n        char c2 = 'A';\n        for (int j = 1; j < i; j++)\n        {\n            cout << c2;\n            c2++;\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patternPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern18.cpp",
      "name": "pattern18.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patternPrint(int n)\n{\n    char c = 'A';\n    c += n - 1;\n    for (int i = 1; i <= n; i++)\n    {\n        char d = c;\n        for (int j = 1; j <= i; j++)\n        {\n            cout << d;\n            d++;\n        }\n        c--;\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patternPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern19.cpp",
      "name": "pattern19.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patterPrint(int n)\n{\n    // upper-half\n    for (int i = 1; i <= n; i++)\n    {\n        // first-star\n        for (int j = i; j <= n; j++)\n        {\n            cout << \"*\";\n        }\n        // space\n        for (int j = 1; j < i; j++)\n        {\n            cout << \" \";\n        }\n        // second-space\n        for (int j = 1; j < i; j++)\n        {\n            cout << \" \";\n        }\n        // second-start\n        for (int j = i; j <= n; j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n    // lower-half\n    for (int i = n; i >= 1; i--)\n    {\n        // first-star\n        for (int j = i; j <= n; j++)\n        {\n            cout << \"*\";\n        }\n        // space\n        for (int j = 1; j < i; j++)\n        {\n            cout << \" \";\n        }\n        // second-space\n        for (int j = 1; j < i; j++)\n        {\n            cout << \" \";\n        }\n        // second-start\n        for (int j = i; j <= n; j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patterPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern2.cpp",
      "name": "pattern2.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patterPrint(int n)\n{\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patterPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern20.cpp",
      "name": "pattern20.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patternPrint(int n)\n{\n    // upper-half\n    for (int i = 1; i <= n; i++)\n    {\n        // first-star\n        for (int j = 1; j <= i; j++)\n        {\n            cout << \"*\";\n        }\n        // first-space\n        for (int j = n; j > i; j--)\n        {\n            cout << \" \";\n        }\n        // second-space\n        for (int j = n; j > i; j--)\n        {\n            cout << \" \";\n        }\n        // second-star\n        for (int j = 1; j <= i; j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n\n    // lower-half\n    for (int i = n; i >= 1; i--)\n    {\n        // first-star\n        for (int j = 1; j <= i; j++)\n        {\n            cout << \"*\";\n        }\n        // first-space\n        for (int j = n; j > i; j--)\n        {\n            cout << \" \";\n        }\n        // second-space\n        for (int j = n; j > i; j--)\n        {\n            cout << \" \";\n        }\n        // second-star\n        for (int j = 1; j <= i; j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patternPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern21.cpp",
      "name": "pattern21.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patternPrint(int n)\n{\n    for (int i = 1; i <= n; i++)\n    {\n        if (i == 1 || i == n)\n        {\n            for (int j = 1; j <= n; j++)\n            {\n                cout << \"*\";\n            }\n        }\n        else\n        {\n            // first-star\n            cout << \"*\";\n            // spaces\n            for (int j = 1; j < n - 1; j++)\n            {\n                cout << \" \";\n            }\n            // second-star\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patternPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern3.cpp",
      "name": "pattern3.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patterPrint(int n)\n{\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n            cout << j;\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patterPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern4.cpp",
      "name": "pattern4.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patterPrint(int n)\n{\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n            cout << i;\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patterPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern5.cpp",
      "name": "pattern5.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patternPrint(int n)\n{\n    for (int i = n; i >= 1; i--)\n    {\n        for (int j = i; j >= 1; j--)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patternPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern6.cpp",
      "name": "pattern6.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patternPrint(int n)\n{\n    for (int i = n; i >= 1; i--)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n            cout << j;\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patternPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern7.cpp",
      "name": "pattern7.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patternPrint(int n)\n{\n    for (int i = 1; i <= n; i++)\n    {\n        // Spaces\n        for (int j = (n-1); j >= i; j--)\n        {\n            cout << \" \";\n        }\n\n        // Star\n        for (int j = 1; j <= (2 * i - 1); j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patternPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern8.cpp",
      "name": "pattern8.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patternPrint(int n)\n{\n    for (int i = n; i >= 1; i--)\n    {\n        // spaces\n        for (int j = (n - 1); j >= i; j--)\n        {\n            cout << \" \";\n        }\n\n        // star\n        for (int j = 1; j <= (2 * i - 1); j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patternPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pattern9.cpp",
      "name": "pattern9.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patternPrint(int n)\n{\n    // upper-half\n    for (int i = 1; i <= n; i++)\n    {\n        // spaces\n        for (int j = (n - 1); j >= i; j--)\n        {\n            cout << \" \";\n        }\n\n        // star\n        for (int j = 1; j <= (2 * i - 1); j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n\n    // lower-half\n    for (int i = n; i >= 1; i--)\n    {\n        // spaces\n        for (int j = (n - 1); j >= i; j--)\n        {\n            cout << \" \";\n        }\n\n        // star\n        for (int j = 1; j <= (2 * i - 1); j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    patternPrint(5);\n    return 0;\n}"
    },
    {
      "path": "patterns/pyramid.cpp",
      "name": "pyramid.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int n = 5;\n\n    // main loop\n    for (int i = 0; i < n; i++)\n    {\n\n        // space loop\n        for (int j = n; j > i + 1; j--)\n        {\n            cout << \" \";\n        }\n\n        // star loop\n        for (int j = 0; j < i + 1; j++)\n        {\n            cout << \" *\";\n        }\n        cout << endl;\n    }\n}"
    },
    {
      "path": "patterns/rightAngleTriangle.cpp",
      "name": "rightAngleTriangle.cpp",
      "content": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int n = 4;\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < i + 1; j++)\n        {\n            cout << \"*\";\n        }\n        cout << endl;\n    }\n}"
    },
    {
      "path": "pointers/pointers.cpp",
      "name": "pointers.cpp",
      "content": "#include <iostream>\n\nusing namespace std;\n\nvoid addressOfVariable()\n{\n    int a = 1;\n    cout << &a << endl;\n}\n\nvoid pointerDeclaration()\n{\n    int price = 100;\n    int *ptr = &price;\n    cout << &price << \"  \" << ptr << \"  \" << &ptr << endl;\n}\n\nvoid pointerToPointer()\n{\n    int a = 1;\n    int *ptr1 = &a;\n    int **ptr2 = &ptr1;\n    cout << &ptr1 << \"  \" << ptr2 << endl;\n}\n\nvoid dereference()\n{\n    int a = 10;\n    int *ptr1 = &a;\n    int **ptr2 = &ptr1;\n    cout << *ptr1 << \"  \" << *ptr2 << \"  \" << **ptr2 << endl;\n}\n\nvoid nullpointer()\n{\n    int *ptr = nullptr;\n    cout << ptr << endl;\n}\n\nvoid pointerAithematic()\n{\n    // Increment and Decrement\n\n    // int a = 10;\n    // int *ptr = &a;\n    // cout << ptr << \"  \";\n    // ptr++;\n    // cout << ptr  << endl;\n\n    // Add and Sub\n    int a = 10;\n    int *ptr = &a;\n    cout << ptr << \"  \";\n    ptr += 2;\n    cout << ptr << endl;\n}\n\nvoid ptrSubtr () {\n    int *ptr2; //100\n    int *ptr1 = ptr2 +2; //108\n\n    cout << ptr1 - ptr2 << endl; //2 Int\n}\n\nint main()\n{\n    addressOfVariable();\n    pointerDeclaration();\n    pointerToPointer();\n    dereference();\n    nullpointer();\n    pointerAithematic();\n    return 0;\n}"
    },
    {
      "path": "referenceClass.cpp",
      "name": "referenceClass.cpp",
      "content": "#include <iostream>\n\nusing namespace std;\n\nvoid passByReference(int &a, int &b, int &c)\n{\n    a = b + c;\n    cout << a << endl;\n}\n\nvoid passByValue(int a, int b, int c)\n{\n    a = b + c;\n    cout << a << endl;\n}\n\nint main()\n{\n    int a = 2;\n    int b = 3;\n    int c = 5;\n\n    // passByReference(a, b, c);\n\n    passByValue(a, b, c);\n\n    cout << a << endl;\n\n    return 0;\n}"
    },
    {
      "path": "searching/binearySearch.cpp",
      "name": "binearySearch.cpp",
      "content": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid search(vector<int> &arr, int target, int start, int end)\n{\n    int mid = start + (end - start) / 2;\n\n    if (arr[mid] == target)\n    {\n        cout << mid << endl;\n    }\n    else if (arr[mid] > target)\n    {\n        search(arr, target, start, mid - 1);\n    }\n    else\n    {\n        search(arr, target, mid + 1, end);\n    }\n}\n\nint main()\n{\n    vector<int> arr = {1, 2, 3, 4, 5, 6};\n    int target = 5;\n    int n = arr.size();\n\n    search(arr, target, 0, n - 1);\n    return 0;\n}"
    },
    {
      "path": "sorting/bubbleSort.cpp",
      "name": "bubbleSort.cpp",
      "content": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid bubbleSort(vector<int> &arr, int n) // Big O(n^2)\n{\n    for (int i = 0; i < n - 1; i++)\n    {\n        bool isSwap = false;\n\n        for (int j = 0; j < n - i - 1; j++)\n        {\n            if (arr[j] > arr[j + 1])\n            {\n                swap(arr[j], arr[j + 1]);\n                isSwap = true;\n            }\n        }\n\n        if (!isSwap)\n        {\n            break;\n        }\n    }\n}\n\nint main()\n{\n    vector<int> arr = {4, 1, 5, 2, 3};\n    int n = arr.size();\n\n    bubbleSort(arr, n);\n\n    for (int i = 0; i < n - 1; i++)\n    {\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"
    },
    {
      "path": "sorting/insertionSort.cpp",
      "name": "insertionSort.cpp",
      "content": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid selectionSort(vector<int> &arr, int n) // O(n^2)\n{\n    for (int i = 1; i < n; i++)\n    {\n        int current = arr[i];\n        int previous = i - 1;\n\n        while (previous >= 0 && arr[previous] > current)\n        {\n            arr[previous + 1] = arr[previous];\n            previous--;\n        }\n\n        arr[previous + 1] = current;\n    }\n}\n\nint main()\n{\n    vector<int> arr = {4, 1, 5, 2, 3};\n    int n = arr.size();\n\n    selectionSort(arr, n);\n\n    for (int i = 0; i < n; i++)\n    {\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
    },
    {
      "path": "sorting/mergeSort.cpp",
      "name": "mergeSort.cpp",
      "content": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid merge(vector<int> &arr, int start, int mid, int end)\n{\n    vector<int> temp;\n    int i = start, j = mid + 1;\n\n    while (i <= mid && j <= end)\n    {\n        if (arr[i] <= arr[j])\n        {\n            temp.push_back(arr[i]);\n            i++;\n        }\n        else\n        {\n            temp.push_back(arr[j]);\n            j++;\n        }\n    }\n\n    while (i <= mid)\n    {\n        temp.push_back(arr[i]);\n        i++;\n    }\n\n    while (j <= end)\n    {\n        temp.push_back(arr[j]);\n        j++;\n    }\n\n    for(int k = start; k <= end; k++){\n        arr[k] = temp[k - start];\n    }\n}\n\nvoid divide(vector<int> &arr, int start, int end)\n{\n    if (start >= end)\n        return;\n\n    int mid = start + (end - start) / 2;\n\n    divide(arr, start, mid);\n\n    divide(arr, mid + 1, end);\n\n    merge(arr, start, mid, end);\n}\n\nint main()\n{\n    vector<int> arr = {7, 3, 2, 6, 0, 1, 5, 4};\n\n    divide(arr, 0, arr.size() - 1);\n\n    for (int n : arr)\n    {\n        cout << n << \" \";\n    }\n    cout << endl;\n}"
    },
    {
      "path": "sorting/quickSort.cpp",
      "name": "quickSort.cpp",
      "content": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid qs(vector<int>& a, int start, int end){\n    \n}\n\nint main()\n{\n    vector<int> a = {4, 6, 2, 5, 7, 9, 1, 3};\n\n    qs(a, 0, a.size() - 1);\n\n    for (int i : a)\n    {\n        cout << i << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
    },
    {
      "path": "sorting/recursiveBubbleSort.cpp",
      "name": "recursiveBubbleSort.cpp",
      "content": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid sort(vector<int> &a, int n)\n{\n    if (n == 1)\n        return;\n\n    bool didSwap = false;\n\n    for (int i = 0; i < n - 1; i++)\n    {\n        if (a[i] > a[i + 1])\n        {\n            swap(a[i], a[i + 1]);\n            didSwap = true;\n        }\n    }\n\n    if (!didSwap)\n        return;\n\n    sort(a, n - 1);\n}\n\nint main()\n{\n    vector<int> a = {7, 3, 2, 1, 6, 5, 4};\n    int n = a.size();\n\n    sort(a, n);\n\n    for (int i : a)\n    {\n        cout << i << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
    },
    {
      "path": "sorting/recursiveInsertionSort.cpp",
      "name": "recursiveInsertionSort.cpp",
      "content": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid sort(vector<int> &a, int n, int i)\n{\n\n    if (i > n)\n        return;\n\n    int j = i;\n\n    while (j > 0 && a[j - 1] > a[j])\n    {\n        swap(a[j - 1], a[j]);\n        j--;\n    }\n\n    sort(a, n, i + 1);\n}\n\nint main()\n{\n    vector<int> a = {13, 46, 24, 52, 20, 9};\n    int n = a.size();\n\n    sort(a, n - 1, 1);\n\n    for (int i : a)\n    {\n        cout << i << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
    },
    {
      "path": "sorting/selectionSort.cpp",
      "name": "selectionSort.cpp",
      "content": "// O(n^2)\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid bubbleSort(vector<int> &arr, int n)\n{\n    for (int i = 0; i < n - 1; i++)\n    {\n        int smallestIdx = i;\n        for (int j = i + 1; j < n; j++)\n        {\n            if (arr[j] < arr[smallestIdx])\n            {\n                smallestIdx = j;\n            }\n        }\n\n        swap(arr[i], arr[smallestIdx]);\n    }\n}\n\nint main()\n{\n    vector<int> arr = {4, 1, 5, 2, 3};\n    int n = arr.size();\n    bubbleSort(arr, n);\n    for (int i = 0; i < n; i++)\n    {\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"
    },
    {
      "path": "sorting/sortArray.cpp",
      "name": "sortArray.cpp",
      "content": "// LC 75\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// O(n^2)\nvoid insertionSort(vector<int> &arr, int n)\n{\n    for (int i = 1; i < n; i++)\n    {\n        int current = arr[i];\n        int previous = i - 1;\n\n        while (previous >= 0 && arr[previous] > current)\n        {\n            arr[previous + 1] = arr[previous];\n            previous--;\n        }\n        arr[previous + 1] = current;\n    }\n}\n\n// O(2n)\nvoid countSort(vector<int> &arr, int n)\n{\n    int count0 = 0, count1 = 0, count2 = 0;\n\n    for (int i = 0; i < n; i++)\n    {\n        if (arr[i] == 0)\n            count0++;\n        else if (arr[i] == 1)\n            count1++;\n        else\n            count2++;\n    }\n\n    int idx = 0;\n\n    for (int i = 0; i < count0; i++)\n    {\n        arr[idx] = 0;\n        idx++;\n    }\n\n    for (int i = 0; i < count1; i++)\n    {\n        arr[idx] = 1;\n        idx++;\n    }\n\n    for (int i = 0; i < count2; i++)\n    {\n        arr[idx] = 2;\n        idx++;\n    }\n}\n\n// Dutch National Flag Algorithm\n// O(n)\nvoid dnf(vector<int> &arr, int n)\n{\n    int low = 0;\n    int mid = 0;\n    int high = n - 1;\n\n    while (mid <= high)\n    {\n        if (arr[mid] == 0)\n        {\n            swap(arr[mid], arr[low]);\n            low++;\n            mid++;\n        }\n        else if (arr[mid] == 1)\n        {\n            mid++;\n        }\n        else\n        {\n            swap(arr[mid], arr[high]);\n            high--;\n        }\n    }\n}\n\nint main()\n{\n    vector<int> arr = {2, 0, 2, 1, 1, 0};\n    int n = arr.size();\n    dnf(arr, n);\n    for (int i = 0; i < n; i++)\n    {\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
    },
    {
      "path": "stl/unorderedSet.cpp",
      "name": "unorderedSet.cpp",
      "content": "#include<iostream>\n#include<unordered_set>\n\nusing namespace std;\n\nint main() {\n  unordered_set < int > s;\n  for (int i = 1; i <= 10; i++) {\n    s.insert(i);\n  }\n\n  cout << \"Elements present in the unordered set: \";\n  for (auto it = s.begin(); it != s.end(); it++) {\n    cout << * it << \" \";\n  }\n  cout << endl;\n  int n = 2;\n  if (s.find(2) != s.end())\n    cout << n << \" is present in unordered set\" << endl;\n\n  s.erase(s.begin());\n  cout << \"Elements after deleting the first element: \";\n  for (auto it = s.begin(); it != s.end(); it++) {\n    cout << * it << \" \";\n  }\n  cout << endl;\n\n  cout << \"The size of the unordered set is: \" << s.size() << endl;\n\n  if (s.empty() == false)\n    cout << \"The unordered set is not empty \" << endl;\n  else\n    cout << \"The unordered set is empty\" << endl;\n  s.clear();\n  cout << \"Size of the unordered set after clearing all the elements: \" << s.size();\n}"
    },
    {
      "path": "stl/vector.cpp",
      "name": "vector.cpp",
      "content": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main() {\n  vector < int > v;\n\n  for (int i = 0; i < 10; i++) {\n    v.push_back(i); //inserting elements in the vector\n  }\n\n  cout << \"the elements in the vector: \";\n  for (auto it = v.begin(); it != v.end(); it++)\n    cout << * it << \" \";\n\n  cout << \"\\nThe front element of the vector: \" << v.front();\n  cout << \"\\nThe last element of the vector: \" << v.back();\n  cout << \"\\nThe size of the vector: \" << v.size();\n  cout << \"\\nDeleting element from the end: \" << v[v.size() - 1];\n  v.pop_back();\n\n  cout << \"\\nPrinting the vector after removing the last element:\" << endl;\n  for (int i = 0; i < v.size(); i++)\n    cout << v[i] << \" \";\n\n  cout << \"\\nInserting 5 at the beginning:\" << endl;\n  v.insert(v.begin(), 5);\n  cout << \"The first element is: \" << v[0] << endl;\n  cout << \"Erasing the first element\" << endl;\n  v.erase(v.begin());\n  cout << \"Now the first element is: \" << v[0] << endl;\n\n  if (v.empty())\n    cout << \"\\nvector is empty\";\n  else\n    cout << \"\\nvector is not empty\" << endl;\n\n  v.clear();\n  cout << \"Size of the vector after clearing the vector: \" << v.size();\n\n}"
    },
    {
      "path": "strings/string.cpp",
      "name": "string.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n    char str[] = {'a', 'b', 'c', '\\0'};\n    char str2[] = \"hello\";\n    char str3[100];\n    // cin.getline(str3, 100);\n    string name = \"vaibhav\";\n    string college;\n    getline(cin, college);\n    cout << college << endl;\n}"
    },
    {
      "path": "validPailondrame.cpp",
      "name": "validPailondrame.cpp",
      "content": "#include <iostream>\n\nusing namespace std;\n\nbool isAlphanumeric(char c)\n{\n    if (c >= 0 && c <= 9)\n        return true;\n    if (c >= 'A' && c <= 'Z')\n        return true;\n    if (c >= 'a' && c <= 'z')\n        return true;\n}\n\nchar lower(char c)\n{\n    if (c >= 'A' && c <= 'Z')\n        return c - 'A' + 'a';\n    return c;\n}\n\nint main()\n{\n    // cout << isAlphanumeric(',') << endl;\n    cout << lower(',') << endl;\n\n    return 0;\n}"
    },
    {
      "path": "vectors/lineraSearch.cpp",
      "name": "lineraSearch.cpp",
      "content": "#include <iostream>\r\nusing namespace std;\r\n\r\nint linearSearchFn(int arr[], int length, int n)\r\n{\r\n    for (int i = 0; i < length; i++)\r\n    {\r\n        if (arr[i] == n)\r\n        {\r\n            return i;\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\nint main()\r\n{\r\n    int arr[] = {2, 8, 9, 7, 3, 4, 5};\r\n    int length = sizeof(arr) / sizeof(arr[0]);\r\n\r\n    int result = linearSearchFn(arr, length, 10);\r\n    if (result != -1)\r\n    {\r\n        cout << \"Found at index: \" << result << endl;\r\n    }\r\n    else\r\n    {\r\n        cout << \"Not found\" << endl;\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
      "path": "vectors/reverseArray.cpp",
      "name": "reverseArray.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid reverse(int arr[], int length)\n{\n    for (int i = 0; i < length / 2; i++)\n    {\n        int temp = arr[length - i - 1];\n        arr[length - i - 1] = arr[i];\n        arr[i] = temp;\n    }\n}\n\nint main()\n{\n    int arr[] = {\n        1,\n        2,\n        3,\n        4,\n        5,\n    };\n    int length = sizeof(arr) / sizeof(arr[0]);\n    reverse(arr, length);\n    cout << \"Reversed array: \";\n    for (int i = 0; i < length; i++)\n    {\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
    },
    {
      "path": "vectors/sumProduct.cpp",
      "name": "sumProduct.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nint sumOfArray(int arr[], int length)\n{\n    int sum = 0;\n    for (int i = 0; i < length; i++)\n    {\n        sum += arr[i];\n    }\n    return sum;\n}\n\nint productOfArray(int arr[], int length)\n{\n    int product = 1;\n    for (int i = 0; i < length; i++)\n    {\n        product *= arr[i];\n    }\n    return product;\n}\n\nint main()\n{\n    int arr[] = {1, 2, 3, 4, 5};\n    int length = sizeof(arr) / sizeof(arr[0]);\n    cout << \"Sum: \" << sumOfArray(arr, length) << \", Product: \" << productOfArray(arr, length) << endl;\n    return 0;\n}"
    },
    {
      "path": "vectors/uniqueNumber.cpp",
      "name": "uniqueNumber.cpp",
      "content": "#include <iostream>\n\nbool isUnique(int arr[], int size, int index)\n{\n    for (int i = 0; i < index; i++)\n    {\n        if (arr[i] == arr[index])\n        {\n            return false; // Value already found earlier\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    int arr[] = {10, 20, 10, 30, 40, 50, 40, 30};\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    std::cout << \"Unique values: \";\n    for (int i = 0; i < size; i++)\n    {\n        if (isUnique(arr, size, i))\n        {\n            std::cout << arr[i] << \" \";\n        }\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n"
    },
    {
      "path": "vectors/vectorEx.cpp",
      "name": "vectorEx.cpp",
      "content": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    vector<int> vec(3, 0);\n    vec.push_back(1);\n\n    cout << vec.back() << endl;\n}"
    }
  ],
  "tree": {
    "name": "",
    "type": "folder",
    "children": {
      "arrays": {
        "name": "arrays",
        "type": "folder",
        "children": {
          "containerWithMostWater.cpp": {
            "name": "containerWithMostWater.cpp",
            "type": "file",
            "path": "arrays/containerWithMostWater.cpp"
          },
          "largestSubarrayZeroSum.cpp": {
            "name": "largestSubarrayZeroSum.cpp",
            "type": "file",
            "path": "arrays/largestSubarrayZeroSum.cpp"
          },
          "longestSubarray.cpp": {
            "name": "longestSubarray.cpp",
            "type": "file",
            "path": "arrays/longestSubarray.cpp"
          },
          "majorityElement.cpp": {
            "name": "majorityElement.cpp",
            "type": "file",
            "path": "arrays/majorityElement.cpp"
          },
          "maxSubarray.cpp": {
            "name": "maxSubarray.cpp",
            "type": "file",
            "path": "arrays/maxSubarray.cpp"
          },
          "merge2SortedArray.cpp": {
            "name": "merge2SortedArray.cpp",
            "type": "file",
            "path": "arrays/merge2SortedArray.cpp"
          },
          "nextPermution.cpp": {
            "name": "nextPermution.cpp",
            "type": "file",
            "path": "arrays/nextPermution.cpp"
          },
          "pairSum.cpp": {
            "name": "pairSum.cpp",
            "type": "file",
            "path": "arrays/pairSum.cpp"
          },
          "productOfArray.cpp": {
            "name": "productOfArray.cpp",
            "type": "file",
            "path": "arrays/productOfArray.cpp"
          },
          "rotateMatrix.cpp": {
            "name": "rotateMatrix.cpp",
            "type": "file",
            "path": "arrays/rotateMatrix.cpp"
          },
          "second.cpp": {
            "name": "second.cpp",
            "type": "file",
            "path": "arrays/second.cpp"
          },
          "spiralMatrix.cpp": {
            "name": "spiralMatrix.cpp",
            "type": "file",
            "path": "arrays/spiralMatrix.cpp"
          },
          "subArray.cpp": {
            "name": "subArray.cpp",
            "type": "file",
            "path": "arrays/subArray.cpp"
          },
          "tempCodeRunnerFile.cpp": {
            "name": "tempCodeRunnerFile.cpp",
            "type": "file",
            "path": "arrays/tempCodeRunnerFile.cpp"
          },
          "twoSum.cpp": {
            "name": "twoSum.cpp",
            "type": "file",
            "path": "arrays/twoSum.cpp"
          },
          "union.cpp": {
            "name": "union.cpp",
            "type": "file",
            "path": "arrays/union.cpp"
          }
        }
      },
      "binarySearch": {
        "name": "binarySearch",
        "type": "folder",
        "children": {
          "SearchInRotatedArray.cpp": {
            "name": "SearchInRotatedArray.cpp",
            "type": "file",
            "path": "binarySearch/SearchInRotatedArray.cpp"
          },
          "aggresiveCow.cpp": {
            "name": "aggresiveCow.cpp",
            "type": "file",
            "path": "binarySearch/aggresiveCow.cpp"
          },
          "binarySearch.cpp": {
            "name": "binarySearch.cpp",
            "type": "file",
            "path": "binarySearch/binarySearch.cpp"
          },
          "book.cpp": {
            "name": "book.cpp",
            "type": "file",
            "path": "binarySearch/book.cpp"
          },
          "floorCeil.cpp": {
            "name": "floorCeil.cpp",
            "type": "file",
            "path": "binarySearch/floorCeil.cpp"
          },
          "nRoot.cpp": {
            "name": "nRoot.cpp",
            "type": "file",
            "path": "binarySearch/nRoot.cpp"
          },
          "occurance.cpp": {
            "name": "occurance.cpp",
            "type": "file",
            "path": "binarySearch/occurance.cpp"
          },
          "paintersPartition.cpp": {
            "name": "paintersPartition.cpp",
            "type": "file",
            "path": "binarySearch/paintersPartition.cpp"
          },
          "peakMountain.cpp": {
            "name": "peakMountain.cpp",
            "type": "file",
            "path": "binarySearch/peakMountain.cpp"
          },
          "singleElement.cpp": {
            "name": "singleElement.cpp",
            "type": "file",
            "path": "binarySearch/singleElement.cpp"
          },
          "sqrt.cpp": {
            "name": "sqrt.cpp",
            "type": "file",
            "path": "binarySearch/sqrt.cpp"
          },
          "upperBound.cpp": {
            "name": "upperBound.cpp",
            "type": "file",
            "path": "binarySearch/upperBound.cpp"
          }
        }
      },
      "bitwise": {
        "name": "bitwise",
        "type": "folder",
        "children": {
          "binaryToDecimal.cpp": {
            "name": "binaryToDecimal.cpp",
            "type": "file",
            "path": "bitwise/binaryToDecimal.cpp"
          },
          "bitManuplation.cpp": {
            "name": "bitManuplation.cpp",
            "type": "file",
            "path": "bitwise/bitManuplation.cpp"
          },
          "decimalToBinary.cpp": {
            "name": "decimalToBinary.cpp",
            "type": "file",
            "path": "bitwise/decimalToBinary.cpp"
          }
        }
      },
      "hashing": {
        "name": "hashing",
        "type": "folder",
        "children": {
          "mapHashing.cpp": {
            "name": "mapHashing.cpp",
            "type": "file",
            "path": "hashing/mapHashing.cpp"
          }
        }
      },
      "maths": {
        "name": "maths",
        "type": "folder",
        "children": {
          "buyAndSell.cpp": {
            "name": "buyAndSell.cpp",
            "type": "file",
            "path": "maths/buyAndSell.cpp"
          },
          "gcd.cpp": {
            "name": "gcd.cpp",
            "type": "file",
            "path": "maths/gcd.cpp"
          },
          "lcm.cpp": {
            "name": "lcm.cpp",
            "type": "file",
            "path": "maths/lcm.cpp"
          },
          "plandromeNumber.cpp": {
            "name": "plandromeNumber.cpp",
            "type": "file",
            "path": "maths/plandromeNumber.cpp"
          },
          "power.cpp": {
            "name": "power.cpp",
            "type": "file",
            "path": "maths/power.cpp"
          },
          "primeNumber.cpp": {
            "name": "primeNumber.cpp",
            "type": "file",
            "path": "maths/primeNumber.cpp"
          },
          "reverseNumber.cpp": {
            "name": "reverseNumber.cpp",
            "type": "file",
            "path": "maths/reverseNumber.cpp"
          }
        }
      },
      "matrices": {
        "name": "matrices",
        "type": "folder",
        "children": {
          "diagonalSum.cpp": {
            "name": "diagonalSum.cpp",
            "type": "file",
            "path": "matrices/diagonalSum.cpp"
          },
          "matrix.cpp": {
            "name": "matrix.cpp",
            "type": "file",
            "path": "matrices/matrix.cpp"
          }
        }
      },
      "oops": {
        "name": "oops",
        "type": "folder",
        "children": {
          "containerClass.cpp": {
            "name": "containerClass.cpp",
            "type": "file",
            "path": "oops/containerClass.cpp"
          },
          "copyConstructor.cpp": {
            "name": "copyConstructor.cpp",
            "type": "file",
            "path": "oops/copyConstructor.cpp"
          },
          "friendClass.cpp": {
            "name": "friendClass.cpp",
            "type": "file",
            "path": "oops/friendClass.cpp"
          },
          "friendFunction.cpp": {
            "name": "friendFunction.cpp",
            "type": "file",
            "path": "oops/friendFunction.cpp"
          },
          "inheriantance.cpp": {
            "name": "inheriantance.cpp",
            "type": "file",
            "path": "oops/inheriantance.cpp"
          },
          "operatorOverloading.cpp": {
            "name": "operatorOverloading.cpp",
            "type": "file",
            "path": "oops/operatorOverloading.cpp"
          },
          "poly.cpp": {
            "name": "poly.cpp",
            "type": "file",
            "path": "oops/poly.cpp"
          }
        }
      },
      "patterns": {
        "name": "patterns",
        "type": "folder",
        "children": {
          "diamondPattern.cpp": {
            "name": "diamondPattern.cpp",
            "type": "file",
            "path": "patterns/diamondPattern.cpp"
          },
          "invertedPyramid.cpp": {
            "name": "invertedPyramid.cpp",
            "type": "file",
            "path": "patterns/invertedPyramid.cpp"
          },
          "patter13.cpp": {
            "name": "patter13.cpp",
            "type": "file",
            "path": "patterns/patter13.cpp"
          },
          "pattern1.cpp": {
            "name": "pattern1.cpp",
            "type": "file",
            "path": "patterns/pattern1.cpp"
          },
          "pattern10.cpp": {
            "name": "pattern10.cpp",
            "type": "file",
            "path": "patterns/pattern10.cpp"
          },
          "pattern11.cpp": {
            "name": "pattern11.cpp",
            "type": "file",
            "path": "patterns/pattern11.cpp"
          },
          "pattern12.cpp": {
            "name": "pattern12.cpp",
            "type": "file",
            "path": "patterns/pattern12.cpp"
          },
          "pattern14.cpp": {
            "name": "pattern14.cpp",
            "type": "file",
            "path": "patterns/pattern14.cpp"
          },
          "pattern15.cpp": {
            "name": "pattern15.cpp",
            "type": "file",
            "path": "patterns/pattern15.cpp"
          },
          "pattern16.cpp": {
            "name": "pattern16.cpp",
            "type": "file",
            "path": "patterns/pattern16.cpp"
          },
          "pattern17.cpp": {
            "name": "pattern17.cpp",
            "type": "file",
            "path": "patterns/pattern17.cpp"
          },
          "pattern18.cpp": {
            "name": "pattern18.cpp",
            "type": "file",
            "path": "patterns/pattern18.cpp"
          },
          "pattern19.cpp": {
            "name": "pattern19.cpp",
            "type": "file",
            "path": "patterns/pattern19.cpp"
          },
          "pattern2.cpp": {
            "name": "pattern2.cpp",
            "type": "file",
            "path": "patterns/pattern2.cpp"
          },
          "pattern20.cpp": {
            "name": "pattern20.cpp",
            "type": "file",
            "path": "patterns/pattern20.cpp"
          },
          "pattern21.cpp": {
            "name": "pattern21.cpp",
            "type": "file",
            "path": "patterns/pattern21.cpp"
          },
          "pattern3.cpp": {
            "name": "pattern3.cpp",
            "type": "file",
            "path": "patterns/pattern3.cpp"
          },
          "pattern4.cpp": {
            "name": "pattern4.cpp",
            "type": "file",
            "path": "patterns/pattern4.cpp"
          },
          "pattern5.cpp": {
            "name": "pattern5.cpp",
            "type": "file",
            "path": "patterns/pattern5.cpp"
          },
          "pattern6.cpp": {
            "name": "pattern6.cpp",
            "type": "file",
            "path": "patterns/pattern6.cpp"
          },
          "pattern7.cpp": {
            "name": "pattern7.cpp",
            "type": "file",
            "path": "patterns/pattern7.cpp"
          },
          "pattern8.cpp": {
            "name": "pattern8.cpp",
            "type": "file",
            "path": "patterns/pattern8.cpp"
          },
          "pattern9.cpp": {
            "name": "pattern9.cpp",
            "type": "file",
            "path": "patterns/pattern9.cpp"
          },
          "pyramid.cpp": {
            "name": "pyramid.cpp",
            "type": "file",
            "path": "patterns/pyramid.cpp"
          },
          "rightAngleTriangle.cpp": {
            "name": "rightAngleTriangle.cpp",
            "type": "file",
            "path": "patterns/rightAngleTriangle.cpp"
          }
        }
      },
      "pointers": {
        "name": "pointers",
        "type": "folder",
        "children": {
          "pointers.cpp": {
            "name": "pointers.cpp",
            "type": "file",
            "path": "pointers/pointers.cpp"
          }
        }
      },
      "referenceClass.cpp": {
        "name": "referenceClass.cpp",
        "type": "file",
        "path": "referenceClass.cpp"
      },
      "searching": {
        "name": "searching",
        "type": "folder",
        "children": {
          "binearySearch.cpp": {
            "name": "binearySearch.cpp",
            "type": "file",
            "path": "searching/binearySearch.cpp"
          }
        }
      },
      "sorting": {
        "name": "sorting",
        "type": "folder",
        "children": {
          "bubbleSort.cpp": {
            "name": "bubbleSort.cpp",
            "type": "file",
            "path": "sorting/bubbleSort.cpp"
          },
          "insertionSort.cpp": {
            "name": "insertionSort.cpp",
            "type": "file",
            "path": "sorting/insertionSort.cpp"
          },
          "mergeSort.cpp": {
            "name": "mergeSort.cpp",
            "type": "file",
            "path": "sorting/mergeSort.cpp"
          },
          "quickSort.cpp": {
            "name": "quickSort.cpp",
            "type": "file",
            "path": "sorting/quickSort.cpp"
          },
          "recursiveBubbleSort.cpp": {
            "name": "recursiveBubbleSort.cpp",
            "type": "file",
            "path": "sorting/recursiveBubbleSort.cpp"
          },
          "recursiveInsertionSort.cpp": {
            "name": "recursiveInsertionSort.cpp",
            "type": "file",
            "path": "sorting/recursiveInsertionSort.cpp"
          },
          "selectionSort.cpp": {
            "name": "selectionSort.cpp",
            "type": "file",
            "path": "sorting/selectionSort.cpp"
          },
          "sortArray.cpp": {
            "name": "sortArray.cpp",
            "type": "file",
            "path": "sorting/sortArray.cpp"
          }
        }
      },
      "stl": {
        "name": "stl",
        "type": "folder",
        "children": {
          "unorderedSet.cpp": {
            "name": "unorderedSet.cpp",
            "type": "file",
            "path": "stl/unorderedSet.cpp"
          },
          "vector.cpp": {
            "name": "vector.cpp",
            "type": "file",
            "path": "stl/vector.cpp"
          }
        }
      },
      "strings": {
        "name": "strings",
        "type": "folder",
        "children": {
          "string.cpp": {
            "name": "string.cpp",
            "type": "file",
            "path": "strings/string.cpp"
          }
        }
      },
      "validPailondrame.cpp": {
        "name": "validPailondrame.cpp",
        "type": "file",
        "path": "validPailondrame.cpp"
      },
      "vectors": {
        "name": "vectors",
        "type": "folder",
        "children": {
          "lineraSearch.cpp": {
            "name": "lineraSearch.cpp",
            "type": "file",
            "path": "vectors/lineraSearch.cpp"
          },
          "reverseArray.cpp": {
            "name": "reverseArray.cpp",
            "type": "file",
            "path": "vectors/reverseArray.cpp"
          },
          "sumProduct.cpp": {
            "name": "sumProduct.cpp",
            "type": "file",
            "path": "vectors/sumProduct.cpp"
          },
          "uniqueNumber.cpp": {
            "name": "uniqueNumber.cpp",
            "type": "file",
            "path": "vectors/uniqueNumber.cpp"
          },
          "vectorEx.cpp": {
            "name": "vectorEx.cpp",
            "type": "file",
            "path": "vectors/vectorEx.cpp"
          }
        }
      }
    }
  }
}